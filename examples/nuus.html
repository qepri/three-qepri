<!DOCTYPE html>
<html lang="en">
<head>
	<title>sergio aguirrre</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">

	<style>
		.fade-in-out {
  animation: fade-in-out 5s infinite;
}

@keyframes fade-in-out {
  5% {
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 1;
  }
}

	</style>
</head>
<body>

	<div id="container"></div>
	<div id="info">
		<!--a href="link" target="_blank" rel="noopener" style="color background-color: black ;hover
		background-color:white;">entrar</a></div-->
	</div>

	<!-- Sergio Aguirrre 2023-->
	<a id="enter" class="changing-hue button_vr" style="text-decoration: none;"href="https://sergioaguirrre.xyz/CV/index.html">
		<img class="fade-in-out" style="width: 126px;height: auto; 
			margin: 0 auto; position: absolute;
 			 top: 50%;
				left: 50.6%;
				bottom: 60%;
				border-radius: 100%;
				box-shadow: 0 0 20px 20px #000000 inset;
				filter: drop-shadow(0px 7px 49px #FFFFFF);
  				transform: translate(-50%, -50%);"
   src="https://sergioaguirrre.xyz/CV/images/logo.png" alt="">

   <script>
  document.getElementById("enter").addEventListener("click", function() {
    window.open("https://sergioaguirrre.xyz/CV/index.html", "_blank");
  });
</script>
	
   <script id="vertexShader" type="x-shader/x-vertex">
		precision highp float;

		uniform float sineTime;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec3 offset;
		attribute vec4 color;
		attribute vec4 orientationStart;
		attribute vec4 orientationEnd;

		varying vec3 vPosition;
		varying vec4 vColor;

		void main(){

			vPosition = offset * max( abs( sineTime * 2.0 + 1.0 ), 0.5 ) + position;
			vec4 orientation = normalize( mix( orientationStart, orientationEnd, sineTime ) );
			vec3 vcV = cross( orientation.xyz, vPosition );
			vPosition = vcV * ( 2.0 * orientation.w ) + ( cross( orientation.xyz, vcV ) * 2.0 + vPosition );

			vColor = color;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );

		}

	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">

		precision highp float;

		uniform float time;

		varying vec3 vPosition;
		varying vec4 vColor;

		void main() {

			vec4 color = vec4( vColor );
			color.r += sin( vPosition.x * 9.0 + time ) * 5.95;

			gl_FragColor = color;

		}

	</script>

	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

	<script type="importmap">
		{
			"imports": {
				"three": "../build/three.module.js"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three';

		import Stats from './jsm/libs/stats.module.js';
		import { GUI } from './jsm/libs/lil-gui.module.min.js';

		let container, stats;

		let camera, scene, renderer;

		init();
		animate();

		function init() {

			container = document.getElementById( 'container' );

			camera = new THREE.PerspectiveCamera( 69, window.innerWidth / window.innerHeight, 2, 10 );
			camera.position.z = 4;

			scene = new THREE.Scene();

			// geometry

			const vector = new THREE.Vector4();

			const instances = 30000;

			const positions = [];
			const offsets = [];
			const colors = [];
			const orientationsStart = [];
			const orientationsEnd = [];

			positions.push( 0.025, - 0.025, 0 );
			positions.push( - 0.625, 0.5, 0 );
			positions.push( 0, 0, 0.025 );

			// instanced attributes

			for ( let i = 0; i < instances; i ++ ) {

				// offsets

				offsets.push( Math.random() - 0.5, Math.random() - 0.35, Math.random());

				// colors

				colors.push( Math.random(), Math.random() * .7, Math.random(), Math.random() );

				// orientation start

				vector.set( Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
				vector.normalize();

				orientationsStart.push( vector.x, vector.y, vector.z, vector.w );

				// orientation end

				vector.set( Math.random() * 5 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 );
				vector.normalize();

				orientationsEnd.push( vector.x, vector.y, vector.z, vector.w );

			}

			const geometry = new THREE.InstancedBufferGeometry();
			//geometry.instanceCount = instances; // set so its initalized for dat.GUI, will be set in first draw otherwise

			geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );

			geometry.setAttribute( 'offset', new THREE.InstancedBufferAttribute( new Float32Array( offsets ), 3 ) );
			geometry.setAttribute( 'color', new THREE.InstancedBufferAttribute( new Float32Array( colors ), 4 ) );
			geometry.setAttribute( 'orientationStart', new THREE.InstancedBufferAttribute( new Float32Array( orientationsStart ), 4 ) );
			geometry.setAttribute( 'orientationEnd', new THREE.InstancedBufferAttribute( new Float32Array( orientationsEnd ), 4 ) );

			// material

			const material = new THREE.RawShaderMaterial( {

				uniforms: {
					'time': { value: 1.0 },
					'sineTime': { value: 1.0 }
				},
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
				side: THREE.DoubleSide,
				transparent: true

			} );

			//

			const mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			//

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );

			if ( renderer.capabilities.isWebGL2 === false && renderer.extensions.has( 'ANGLE_instanced_arrays' ) === false ) {

				document.getElementById( 'notSupported' ).style.display = '';
				return;

			}

			//

			//const gui = new GUI( { width: 350 } );
			//gui.add( geometry, 'instanceCount', 0, instances );

			// fps information

			//stats = new Stats();
			//container.appendChild( stats.dom );

			//

			window.addEventListener( 'resize', onWindowResize );

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		//

		function animate() {

			requestAnimationFrame( animate );

			render();
			update();

		}

		function render() {

			const time = performance.now();

			const object = scene.children[ 0 ];

			object.rotation.y = time * 0.0005;
			object.material.uniforms[ 'time' ].value = time * 0.005;
			object.material.uniforms[ 'sineTime' ].value = Math.sin( object.material.uniforms[ 'time' ].value * 0.05 );

			renderer.render( scene, camera );

		}

	</script>

</body>

</html>
